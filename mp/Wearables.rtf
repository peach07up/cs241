{\rtf1\ansi\ansicpg936\cocoartf1348\cocoasubrtf170
{\fonttbl\f0\fswiss\fcharset0 Helvetica;\f1\fswiss\fcharset0 Helvetica-Light;\f2\fmodern\fcharset0 Courier;
}
{\colortbl;\red255\green255\blue255;\red48\green58\blue166;\red51\green51\blue51;\red249\green249\blue249;
\red98\green98\blue98;\red26\green26\blue26;\red66\green199\blue218;\red19\green151\blue241;\red29\green30\blue26;
\red252\green34\blue110;\red224\green213\blue97;}
{\*\listtable{\list\listtemplateid1\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid1\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid1}
{\list\listtemplateid2\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid101\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid2}
{\list\listtemplateid3\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}}{\leveltext\leveltemplateid201\'01\'00;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listname ;}\listid3}
{\list\listtemplateid4\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid301\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid4}
{\list\listtemplateid5\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid401\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid5}}
{\*\listoverridetable{\listoverride\listid1\listoverridecount0\ls1}{\listoverride\listid2\listoverridecount0\ls2}{\listoverride\listid3\listoverridecount0\ls3}{\listoverride\listid4\listoverridecount0\ls4}{\listoverride\listid5\listoverridecount0\ls5}}
\paperw11900\paperh16840\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\deftab720
\pard\pardeftab720\qc

\f0\fs48 \cf1 \cb2 \expnd0\expndtw0\kerning0
menu
\fs52 \expnd0\expndtw0\kerning0
\
\pard\pardeftab720

\fs28 \cf1 \expnd0\expndtw0\kerning0
Title
\fs40 \cb1 \expnd0\expndtw0\kerning0
\
\pard\pardeftab720
\cf1 \cb2 CS 241 : System Programming\cb1 \
\pard\pardeftab720

\fs28 \cf1 \cb2 \expnd0\expndtw0\kerning0
Add spacer, to align navigation to the right\cb1 \expnd0\expndtw0\kerning0
\
\
\cb2 \expnd0\expndtw0\kerning0
Navigation. We hide it in small screens.
\fs26 \cb1 \expnd0\expndtw0\kerning0
\
\pard\pardeftab720
{\field{\*\fldinst{HYPERLINK "http://illinois-cs.github.io/index.html"}}{\fldrslt \cf1 \cb2 Overview}}\
\pard\pardeftab720
{\field{\*\fldinst{HYPERLINK "http://illinois-cs.github.io/mps.html"}}{\fldrslt \cf1 \cb2 MPs}}\
{\field{\*\fldinst{HYPERLINK "http://illinois-cs.github.io/labs.html"}}{\fldrslt \cb2 Lab Sections}}\
{\field{\*\fldinst{HYPERLINK "http://illinois-cs.github.io/help.html"}}{\fldrslt \cb2 Getting Help}}\
{\field{\*\fldinst{HYPERLINK "http://illinois-cs.github.io/schedule.html"}}{\fldrslt \cb2 Schedule}}\
{\field{\*\fldinst{HYPERLINK "http://illinois-cs.github.io/staff.html"}}{\fldrslt \cb2 Meet the Crew!}}\
\pard\pardeftab720

\fs40 \cf3 \cb4 \expnd0\expndtw0\kerning0
CS 241\cb1 \
\pard\pardeftab720
{\field{\*\fldinst{HYPERLINK "http://illinois-cs.github.io/index.html"}}{\fldrslt 
\fs26 \cf5 \cb4 \expnd0\expndtw0\kerning0
Overview}}
\fs26 \cf5 \expnd0\expndtw0\kerning0
\
\pard\pardeftab720
{\field{\*\fldinst{HYPERLINK "http://illinois-cs.github.io/mps.html"}}{\fldrslt \cf5 \cb4 \expnd0\expndtw0\kerning0
MPs}}\
\pard\pardeftab720
{\field{\*\fldinst{HYPERLINK "http://illinois-cs.github.io/labs.html"}}{\fldrslt \cf5 \cb4 \expnd0\expndtw0\kerning0
Lab Sections}}\
\pard\pardeftab720
{\field{\*\fldinst{HYPERLINK "http://illinois-cs.github.io/help.html"}}{\fldrslt \cf5 \cb4 \expnd0\expndtw0\kerning0
Getting Help}}\
\pard\pardeftab720
{\field{\*\fldinst{HYPERLINK "http://illinois-cs.github.io/schedule.html"}}{\fldrslt \cf5 \cb4 \expnd0\expndtw0\kerning0
Schedule}}\
\pard\pardeftab720
{\field{\*\fldinst{HYPERLINK "http://illinois-cs.github.io/staff.html"}}{\fldrslt \cf5 \cb4 \expnd0\expndtw0\kerning0
Meet the Crew!}}\
\pard\pardeftab720

\fs28 \cf6 \expnd0\expndtw0\kerning0
Your content goes here\
\pard\pardeftab720

\fs112 \cf6 \expnd0\expndtw0\kerning0
Wearables\
\pard\pardeftab720

\fs28 \cf6 \expnd0\expndtw0\kerning0
\
\pard\tx220\tx720\pardeftab720\li720\fi-720
\ls1\ilvl0
\b \cf6 \kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
Due Date(s):
\b0 \expnd0\expndtw0\kerning0
 May 4th 
\fs26 \expnd0\expndtw0\kerning0
Contents\uc0\u8232 
\fs32 \cf7 \expnd0\expndtw0\kerning0
Wearables\uc0\u8232 Information\u8232 Server\u8232 Data\u8232 Analyze\u8232 Close Gracefully\u8232 Building and Running Your Server\u8232 Input Format\u8232 Food For Thought\u8232 Grading, Submission, and Other Details
\fs28 \cf6 \expnd0\expndtw0\kerning0
\
\pard\pardeftab720

\f1\fs48 \cf1 \cb8 \expnd0\expndtw0\kerning0
Wearables
\f0\fs32 \cf6 \cb1 \expnd0\expndtw0\kerning0
\
\pard\pardeftab720

\fs28 \cf6 \expnd0\expndtw0\kerning0
It\'92s Friday, and you\'92ve sent your employees home for the weekend. Your startup just hit a major milestone, and you\'92re relaxing at the Thomas M. Siebel Bar for Computer Science. You end up sitting next to a scruffy-looking chap, him turning out to be the smartest you\'92ve met so far, and you\'92ve talked to him for hours when he drops the bomb:\
\'93By the way, my name is Terry Paige.\'94 The founder of Broogle.\
Terry continues. \'93What was your startup called, again?\'94\
\'93Uh, Tearable Inc.\'94\
\'93Well, Tearable is working on exactly the kind of clothing sensors we\'92re interested in. We also just funded 241andme, an interesting healthcare startup that I think can synergize with Tearable. Let\'92s schedule a meeting for next Monday, May 4 at 11:59pm\'96show me what you\'92ve got, and we may be interested in bringing you and your team on board. Sound good?\'94\
\'93Y-y-y-y-yes.\'94\
You\'92ve worked for years for this opportunity. On top of this, your biotech wearable startup just struck a deal with manufacturers and hardware engineers to create affordable wearables at massive scale, so you have the hardware.\
All that\'92s left before the demo is the software that connects everything together. Let\'92s get rolling.\
\pard\pardeftab720

\f1\fs48 \cf1 \cb8 \expnd0\expndtw0\kerning0
Information
\f0\fs32 \cf6 \cb1 \expnd0\expndtw0\kerning0
\
\pard\pardeftab720

\fs28 \cf6 \expnd0\expndtw0\kerning0
The purpose of this MP is to scratch the surface of networking and introduce the client-server programming model.\
\'93Every network application is based on the client-server model. With this model, an application consists of a server process and one or more client processes. The server manages some resource, and it provides some service for its clients by manipulating that resource.\'94\
The data your wearables collect are limited to three different types:\
\pard\tx220\tx720\pardeftab720\li720\fi-720
\ls2\ilvl0\cf6 \kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
Heartbeats per minute\
\ls2\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
Blood sugar\
\ls2\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
Body temperature\
\pard\pardeftab720
\cf6 \expnd0\expndtw0\kerning0
Your wearables can already collect and transmit this data. You need the server to hold a user\'92s personal data as well as run some analytics on this data.\
Luckily, you\'92ve kept some consultants on retainer. They\'92ve drafted out some tasks for you:\
\pard\tx220\tx720\pardeftab720\li720\fi-720
\ls3\ilvl0\cf6 \kerning1\expnd0\expndtw0 {\listtext	1	}\expnd0\expndtw0\kerning0
Setup your server\
\ls3\ilvl0\kerning1\expnd0\expndtw0 {\listtext	2	}\expnd0\expndtw0\kerning0
Collect data\
\ls3\ilvl0\kerning1\expnd0\expndtw0 {\listtext	3	}\expnd0\expndtw0\kerning0
Analyze\
\ls3\ilvl0\kerning1\expnd0\expndtw0 {\listtext	4	}\expnd0\expndtw0\kerning0
Close\
\pard\pardeftab720

\f1\fs48 \cf1 \cb8 \expnd0\expndtw0\kerning0
Server
\f0\fs32 \cf6 \cb1 \expnd0\expndtw0\kerning0
\
\pard\pardeftab720

\fs28 \cf6 \expnd0\expndtw0\kerning0
Your server will be provided two port numbers as command line arguments when it runs. One port is reserved for your server to receive data from wearables and the other one is used for clients to request data from your server. These ports will be called the 
\f2 \expnd0\expndtw0\kerning0
wearable port
\f0 \expnd0\expndtw0\kerning0
 and the 
\f2 \expnd0\expndtw0\kerning0
request port
\f0 \expnd0\expndtw0\kerning0
 respectively; you\'92ll need to accept connections from both of these.\
There could be numerous connections running simultaneously on the wearable port, and each of which could last an arbitrary amount of time. As such, you should create a thread for each new connection. For the 
\f2 \expnd0\expndtw0\kerning0
request port
\f0 \expnd0\expndtw0\kerning0
, however, only one client will connect at any single time.\
\pard\pardeftab720

\f1\fs48 \cf1 \cb8 \expnd0\expndtw0\kerning0
Data
\f0\fs32 \cf6 \cb1 \expnd0\expndtw0\kerning0
\
\pard\pardeftab720

\fs28 \cf6 \expnd0\expndtw0\kerning0
Once a connection has been established between a wearable and your server, the wearable send data to your server which is in the form 
\f2 \expnd0\expndtw0\kerning0
<timestamp>:<value>:<type>
\f0 \expnd0\expndtw0\kerning0
,where 
\f2 \expnd0\expndtw0\kerning0
<timestamp>
\f0 \expnd0\expndtw0\kerning0
 and 
\f2 \expnd0\expndtw0\kerning0
<value>
\f0 \expnd0\expndtw0\kerning0
 are integer values, while 
\f2 \expnd0\expndtw0\kerning0
<type>
\f0 \expnd0\expndtw0\kerning0
 will correspond to one of the three strings: 
\f2 \expnd0\expndtw0\kerning0
heart_beat
\f0 \expnd0\expndtw0\kerning0
, 
\f2 \expnd0\expndtw0\kerning0
blood_sugar
\f0 \expnd0\expndtw0\kerning0
, 
\f2 \expnd0\expndtw0\kerning0
body_temp
\f0 \expnd0\expndtw0\kerning0
.\
You are responsible for saving this data for later processing and analysis. We have provided files 
\f2 \expnd0\expndtw0\kerning0
queue.c
\f0 \expnd0\expndtw0\kerning0
 and 
\f2 \expnd0\expndtw0\kerning0
queue.h
\f0 \expnd0\expndtw0\kerning0
, which contain implementation of a queue that stores timestamped data, and helper functions to get data between certain timestamp ranges. See 
\f2 \expnd0\expndtw0\kerning0
queue.h
\f0 \expnd0\expndtw0\kerning0
 for details.\
Please note that this queue is not thread safe so you will be responsible for synchronization on it.\
A slight simplification for this MP: you can assume that data will always arrive in 64 byte packets because the wearable clients are actually running on the same localhost. Thus, you can read socket data in in blocks of 64 bytes and parse each block as a new data item. A real server might have to stitch multiple blocks together because the packets can arrive in arbitrary sizes as they are routed around the Internet.\
\pard\pardeftab720

\f1\fs48 \cf1 \cb8 \expnd0\expndtw0\kerning0
Analyze
\f0\fs32 \cf6 \cb1 \expnd0\expndtw0\kerning0
\
\pard\pardeftab720

\fs28 \cf6 \expnd0\expndtw0\kerning0
Your server is useless if others cannot query it, so we will also open up a port (the given 
\f2 \expnd0\expndtw0\kerning0
request port
\f0 \expnd0\expndtw0\kerning0
) where a client can send a request to. A request to your server will be done in the following steps:\
\pard\tx220\tx720\pardeftab720\li720\fi-720
\ls4\ilvl0\cf6 \kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
A client opens a socket on the request port which is handled in its own thread. For simplicity, there will be only one connection to the request socket, so you can safely close the server socket after the client closes the connection. This portion of code is already provided (wearables.c).\
\ls4\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
A client sends a request by sending the string 
\f2 \expnd0\expndtw0\kerning0
<timestamp_start>:<timestamp_end>
\f0 \expnd0\expndtw0\kerning0
 (where the timestamps are both integers).\
\ls4\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
Your server parses the request and collects all data received between those 2 timestamps. Data should be collected in the inclusive-exclusive range [:). To gather information about queue events within a timestamp range you can use the given function `queue_gather()`--see its documentation for more details.\
\ls4\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
If any wearable connection has not received data up to the end timestamp yet (and has not closed yet), you must wait until that wearable thread receives a timestamp greater than or equal to the end timestamp before sending request data to the user. Furthermore, if a wearable thread has finished collecting data and closed its respective socket, you still need to include its data. You will need to use some sort of synchronization to ensure that you do not send out the data too early (before every thread has either received past the given timestamp or finished).\
\ls4\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
While you will receive no credit for sending data out too early, you may be thinking that you can just service all requests from the user when all wearables have finished, eliminating the need for advanced synchronization. Solutions that do this will only receive 25% of the maximum possible score. The data should be sent as soon as it is available, but we provide a small tolerance for network delay.\
\ls4\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
When you have received all the data, you will send out the median and mean of the data for each type. We have provided the method 
\f2 \expnd0\expndtw0\kerning0
write_results()
\f0 \expnd0\expndtw0\kerning0
, which (given a file descriptor, 
\f2 \expnd0\expndtw0\kerning0
char* type
\f0 \expnd0\expndtw0\kerning0
, and results set) will write out the required statistics. You should call this method for each type in order, i.e. 
\f2 \expnd0\expndtw0\kerning0
write_results(fd, TYPE1 \'85)
\f0 \expnd0\expndtw0\kerning0
, 
\f2 \expnd0\expndtw0\kerning0
write_results(fd, TYPE2 ....)
\f0 \expnd0\expndtw0\kerning0
, etc. Further, you must write the string 
\f2 \expnd0\expndtw0\kerning0
"\\r\\n"
\f0 \expnd0\expndtw0\kerning0
 to the file descriptor after your 3 calls to write_results.\
\ls4\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
For simplicity, there will be only one client connect to the request socket, so you can safely close the server socket after the client closes the connection. This portion of code is provided already. Please note that the single client might connect to your server any time while your sever is running, and it might send multiple requests separated by arbitrary delays during its connection.\
\ls4\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
A request that the client sends follows the format 
\f2 \expnd0\expndtw0\kerning0
<timestamp_start>:<timestamp_end>
\f0 \expnd0\expndtw0\kerning0
, where the timestamps are both integers.\
\ls4\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
Your server parses the request and collects all data received from wearables between those two timestamps specified in the request. Data should be collected in the inclusive-exclusive range i.e. [:). To gather information about queue events within such timestamp range you can use the given function `queue_gather()` (see its documentation for more details).\
\ls4\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
If any active wearable connection has not received data up to the end timestamp (
\f2 \expnd0\expndtw0\kerning0
<timestamp_end>
\f0 \expnd0\expndtw0\kerning0
 in the request), you must wait until that wearable thread receives data that has a timestamp greater than or equal to the end timestamp before replying the client\'92s request. Furthermore, if a wearable thread has finished sending data and closed its connection, you still need to include its data in your reply. You will need to use some sort of synchronization to ensure that you do not send out the data too early (before you satisfy the above requirements).\
\ls4\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
While you will receive no credit for sending data out too early, you may be thinking that you can just reply all requests from the client after all wearables have finished, eliminating the need for advanced synchronization. Solutions that do this will only receive 25% of the maximum possible score. The data should be sent as soon as it is available, but we provide a small tolerance for network delay.\
\ls4\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
When you decide to reply for a request, you will send out the median and mean of the data for each type. We have provided the method 
\f2 \expnd0\expndtw0\kerning0
write_results()
\f0 \expnd0\expndtw0\kerning0
, which (given a file descriptor, 
\f2 \expnd0\expndtw0\kerning0
char* type
\f0 \expnd0\expndtw0\kerning0
, and results set) will write out the required statistics. You should call this method for each type in order, i.e. 
\f2 \expnd0\expndtw0\kerning0
write_results(fd, TYPE1 \'85)
\f0 \expnd0\expndtw0\kerning0
, 
\f2 \expnd0\expndtw0\kerning0
write_results(fd, TYPE2 ....)
\f0 \expnd0\expndtw0\kerning0
, etc. Further, you must write the string 
\f2 \expnd0\expndtw0\kerning0
"\\r\\n"
\f0 \expnd0\expndtw0\kerning0
 to the file descriptor after your 3 calls to write_results.\
\pard\pardeftab720
\cf6 \expnd0\expndtw0\kerning0
Please don\'92t use busy-waiting i.e. wait for all the data and then send the information; you\'92ll want to use a mutex and condition wait instead. The wikibook is a great resource to learn about correct use of condition variables.\
\pard\pardeftab720

\f1\fs48 \cf1 \cb8 \expnd0\expndtw0\kerning0
Close Gracefully
\f0\fs32 \cf6 \cb1 \expnd0\expndtw0\kerning0
\
\pard\pardeftab720

\fs28 \cf6 \expnd0\expndtw0\kerning0
Your server will stop accepting connections when you receive the interrupt signal (SIGINT), and will exit gracefully (i.e. freeing all memory and closing all ports) after all wearable connections have closed. In all of the tests you can assume the client has connected to the request socket and the SIGINT signal is only sent after the user has finished requesting data.\
\pard\pardeftab720

\f1\fs48 \cf1 \cb8 \expnd0\expndtw0\kerning0
Building and Running Your Server
\f0\fs32 \cf6 \cb1 \expnd0\expndtw0\kerning0
\
\pard\pardeftab720

\fs28 \cf6 \expnd0\expndtw0\kerning0
To build the server, run 
\f2 \expnd0\expndtw0\kerning0
make
\f0 \expnd0\expndtw0\kerning0
.\
We\'92ve provided a wearables simulator for your testing purposes, so you can focus on creating the server. Recall that your server takes 2 ports\'96wearables and request. Starting your server, where 8888 and 8889 are arbitrary ports, should look like:\
\pard\pardeftab720

\f2\fs32 \cf1 \cb9 \expnd0\expndtw0\kerning0
% ./wearable_server 8888 8889 \
\pard\pardeftab720

\f0\fs28 \cf6 \cb1 \expnd0\expndtw0\kerning0
Once your server has started, you can begin the wearables simulator which will simulate sending data from wearables and requests. We\'92ve included some basic but insufficient test scripts to check your output against. They\'92re human-readable, so you can create your own tests to verify your output with one command on each line. Please make sure your server is restarted before every simulator run.\
\pard\pardeftab720

\f2\fs32 \cf1 \cb9 \expnd0\expndtw0\kerning0
% ./wearable_sim 8888 8889 tests/[Testname].ww\
\pard\pardeftab720

\f0\fs28 \cf6 \cb1 \expnd0\expndtw0\kerning0
While the simulator is running, it will report back the data you sent from your server. Additionally, it also generates the expected output for you to compare against. After running the simulator you should see 3 files, 
\f2 \expnd0\expndtw0\kerning0
_expected.rp
\f0 \expnd0\expndtw0\kerning0
, 
\f2 \expnd0\expndtw0\kerning0
_received.rp
\f0 \expnd0\expndtw0\kerning0
, and 
\f2 \expnd0\expndtw0\kerning0
_error_report.rp
\f0 \expnd0\expndtw0\kerning0
. 
\f2 \expnd0\expndtw0\kerning0
_received.rp
\f0 \expnd0\expndtw0\kerning0
 will hold the exact data sent from your server, so to see if your output is correct after running the simulator, you can use:\
\pard\pardeftab720

\f2\fs32 \cf1 \cb9 \expnd0\expndtw0\kerning0
% diff _received.rp _expected.rp\
\pard\pardeftab720

\f0\fs28 \cf6 \cb1 \expnd0\expndtw0\kerning0
or\
\pard\pardeftab720

\f2\fs32 \cf1 \cb9 \expnd0\expndtw0\kerning0
% bash check_solution.sh\
\pard\pardeftab720

\f0\fs28 \cf6 \cb1 \expnd0\expndtw0\kerning0
Please note that 
\f2 \expnd0\expndtw0\kerning0
_error_report.rp
\f0 \expnd0\expndtw0\kerning0
 will hold any errors that may have been encountered while running the simulator.\
You can create your tests like this:\
\pard\pardeftab720

\f2\fs32 \cf1 \cb9 \expnd0\expndtw0\kerning0
BEGIN - Signifies the beginning of a wearable definition.\
START: - States how much time before this wearable begins transmitting information.\
INTERVAL: - States the time delay between sending data points. <type>:<value> - One data point, where type is a string corresponding TYPE1, TYPE2, TYPE3. Value is an integer. Note all data points are transmitted sequentially by order in which they appear in a BEGIN-END wearable definition.\
END - Signifies the end of a wearable definition\
SAMPLE_INT:<wait time>:<timestamp1>:<timestamp2> - Simulates a user request.\
\pard\pardeftab720

\f0\fs28 \cf6 \cb1 \expnd0\expndtw0\kerning0
There can be multiple commands of this time, and the are simulated sequentially. 
\f2 \expnd0\expndtw0\kerning0
<wait time>
\f0 \expnd0\expndtw0\kerning0
 represents the time (in millis) to sleep before this request is sent. The timestamp values represent the range of timestamps requested.\
A basic test that creates one wearable which starts 1 second after the simulator is started, with 3 data points (send every second) and requests timestamp between 0, 2000 (with the request started 2 seconds after) would look like:\
\pard\pardeftab720

\f2\fs32 \cf1 \cb9 \expnd0\expndtw0\kerning0
SAMPLE_INT:2000:0:2000\
BEGIN\
START:1000\
INTERVAL:1000\
heart_beat:100\
blood_sugar:104\
body_temp:104\
END\
\pard\pardeftab720

\f0\fs28 \cf6 \cb1 \expnd0\expndtw0\kerning0
This test script would send the data:\
\pard\pardeftab720

\f2\fs32 \cf1 \cb9 \expnd0\expndtw0\kerning0
1000:heart_beat:100\
2000:blood_sugar:104\
3000:body_temp:104\
\pard\pardeftab720

\f0\fs28 \cf6 \cb1 \expnd0\expndtw0\kerning0
and the expected output would be:\
\pard\pardeftab720

\f2\fs32 \cf1 \cb9 \expnd0\expndtw0\kerning0
Results for heart_beat:\
Size:1\
0 100\
Median:100\
Average:100\
Results for blood_sugar:\
Size:0\
Median:0\
Average:0\
Results for body_temp:\
Size:0\
Median:0\
Average:0\
\pard\pardeftab720

\f0\fs28 \cf6 \cb1 \expnd0\expndtw0\kerning0
If you want to kill the wearable server: You might have to do this if you have not implemented the signal handler or if your socket isn\'92t closed properly.\
First, find the pid of the process by running 
\f2 \expnd0\expndtw0\kerning0
netstat -tulnap | grep :<port number>
\f0 \expnd0\expndtw0\kerning0
 with the appropriate port number.\
Then, kill the process by running 
\f2 \expnd0\expndtw0\kerning0
kill -9 <pid>
\f0 \expnd0\expndtw0\kerning0
 with the appropriate pid.\
\pard\pardeftab720

\f1\fs48 \cf1 \cb8 \expnd0\expndtw0\kerning0
Input Format
\f0\fs32 \cf6 \cb1 \expnd0\expndtw0\kerning0
\
\pard\pardeftab720

\fs28 \cf6 \expnd0\expndtw0\kerning0
You can safely assume that we will provide all input in the format stated above. However, it might be helpful for you own debugging purposes to add some error handling routines in your server program.\
\pard\pardeftab720

\f1\fs48 \cf1 \cb8 \expnd0\expndtw0\kerning0
Food For Thought
\f0\fs32 \cf6 \cb1 \expnd0\expndtw0\kerning0
\
\pard\pardeftab720

\fs28 \cf6 \expnd0\expndtw0\kerning0
This portion is ungraded, but you may find it helpful for both checking understanding and for future assessments.\
\pard\tx220\tx720\pardeftab720\li720\fi-720
\ls5\ilvl0\cf6 \kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
How is a domain name converted to an IP address? What could be some of the benefits of caching DNS lookups?\
\ls5\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
Describe the purposes of the pthread_join and pthread_create calls, and how threads can be used in C servers.\
\ls5\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
What are the advantages of TCP over UDP? What are the disadvantages? Can you think of a use case where UDP would be a better choice? Think about this, then see {\field{\*\fldinst{HYPERLINK "https://www.quora.com/Why-does-Netflix-use-TCP-and-not-UDP-for-its-streaming-video"}}{\fldrslt \cf10 \expnd0\expndtw0\kerning0
Quora on why Netflix uses TCP instead of UDP}} for streaming video if you\'92re interested.\
\ls5\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
What is the \'93TCP Handshake\'94?\
\ls5\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
Explain in plain English what sockets are, and how we use them inside Unix programs (hint: think files). How are sockets different from other files you have encountered `so far? (Do they have inode metadata? Do writes on sockets result in Disk I/O?).\
\ls5\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
How are sockets related to ports? Can you think of a way to uniquely identify a connection with sockets? What could be some reasons to allow for the reusing of ports?\
\ls5\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
Does TCP encrypt packets that are sent over the network? If not, what are some ways in which encryption is carried out?\
\pard\pardeftab720

\f1\fs48 \cf1 \cb8 \expnd0\expndtw0\kerning0
Grading, Submission, and Other Details
\f0\fs32 \cf6 \cb1 \expnd0\expndtw0\kerning0
\
\pard\pardeftab720

\fs28 \cf6 \expnd0\expndtw0\kerning0
Please fully read details on {\field{\*\fldinst{HYPERLINK "https://courses.engr.illinois.edu/cs241/#/overview%23integrity"}}{\fldrslt \cf10 \expnd0\expndtw0\kerning0
Academic Honesty}}. These are shared between all MPs in CS 241.\
To check out the provided code for wearables from the class repository, go to your cs241 directory (the one you checked out for \'93know your tools\'94) and run:\
\pard\pardeftab720

\f2\fs32 \cf1 \cb9 \expnd0\expndtw0\kerning0
 svn up \
\pard\pardeftab720

\f0\fs28 \cf6 \cb1 \expnd0\expndtw0\kerning0
If you run ls you will now see a wearables folder, where you can find this assignment! To commit your changes (send them to us) type:\
\pard\pardeftab720

\f2\fs32 \cf1 \cb9 \expnd0\expndtw0\kerning0
 svn ci -m \cf11 \expnd0\expndtw0\kerning0
"wearables submission"\cf1 \expnd0\expndtw0\kerning0
 \
\pard\pardeftab720

\f0\fs28 \cf6 \cb1 \expnd0\expndtw0\kerning0
Your repository directory can be viewed from a web browser from the following URL: https://subversion.ews.illinois.edu/svn/sp16-cs241/NETID/wearables where NETID is your University NetID.\
You will implement the logic for your server in wearable_server.c. This file will be used for grading.\
It is important to check that the files you expect to be graded are present and up to date in your svn copy.}