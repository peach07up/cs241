{\rtf1\ansi\ansicpg936\cocoartf1348\cocoasubrtf170
{\fonttbl\f0\fswiss\fcharset0 Helvetica;\f1\fswiss\fcharset0 Helvetica-Light;\f2\fmodern\fcharset0 Courier;
\f3\fmodern\fcharset0 Courier-Bold;\f4\fnil\fcharset0 LucidaGrande;}
{\colortbl;\red255\green255\blue255;\red48\green58\blue166;\red51\green51\blue51;\red249\green249\blue249;
\red98\green98\blue98;\red26\green26\blue26;\red66\green199\blue218;\red19\green151\blue241;\red88\green209\blue235;
\red29\green30\blue26;\red246\green246\blue239;\red244\green0\blue95;\red157\green101\blue255;\red224\green213\blue97;
\red130\green0\blue63;\red22\green0\blue14;\red252\green34\blue110;\red98\green94\blue76;}
{\*\listtable{\list\listtemplateid1\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid1\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid1}
{\list\listtemplateid2\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid101\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid2}
{\list\listtemplateid3\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid201\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid3}
{\list\listtemplateid4\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid301\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid4}
{\list\listtemplateid5\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid401\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid5}
{\list\listtemplateid6\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid501\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid6}
{\list\listtemplateid7\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid601\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid7}}
{\*\listoverridetable{\listoverride\listid1\listoverridecount0\ls1}{\listoverride\listid2\listoverridecount0\ls2}{\listoverride\listid3\listoverridecount0\ls3}{\listoverride\listid4\listoverridecount0\ls4}{\listoverride\listid5\listoverridecount0\ls5}{\listoverride\listid6\listoverridecount0\ls6}{\listoverride\listid7\listoverridecount0\ls7}}
\paperw11900\paperh16840\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\deftab720
\pard\pardeftab720\qc

\f0\fs48 \cf1 \cb2 \expnd0\expndtw0\kerning0
menu
\fs52 \expnd0\expndtw0\kerning0
\
\pard\pardeftab720

\fs28 \cf1 \expnd0\expndtw0\kerning0
Title
\fs40 \cb1 \expnd0\expndtw0\kerning0
\
\pard\pardeftab720
\cf1 \cb2 CS 241 : System Programming\cb1 \
\pard\pardeftab720

\fs28 \cf1 \cb2 \expnd0\expndtw0\kerning0
Add spacer, to align navigation to the right\cb1 \expnd0\expndtw0\kerning0
\
\
\cb2 \expnd0\expndtw0\kerning0
Navigation. We hide it in small screens.
\fs26 \cb1 \expnd0\expndtw0\kerning0
\
\pard\pardeftab720
{\field{\*\fldinst{HYPERLINK "http://illinois-cs.github.io/index.html"}}{\fldrslt \cf1 \cb2 Overview}}\
\pard\pardeftab720
{\field{\*\fldinst{HYPERLINK "http://illinois-cs.github.io/mps.html"}}{\fldrslt \cf1 \cb2 MPs}}\
{\field{\*\fldinst{HYPERLINK "http://illinois-cs.github.io/labs.html"}}{\fldrslt \cb2 Lab Sections}}\
{\field{\*\fldinst{HYPERLINK "http://illinois-cs.github.io/help.html"}}{\fldrslt \cb2 Getting Help}}\
{\field{\*\fldinst{HYPERLINK "http://illinois-cs.github.io/schedule.html"}}{\fldrslt \cb2 Schedule}}\
{\field{\*\fldinst{HYPERLINK "http://illinois-cs.github.io/staff.html"}}{\fldrslt \cb2 Meet the Crew!}}\
\pard\pardeftab720

\fs40 \cf3 \cb4 \expnd0\expndtw0\kerning0
CS 241\cb1 \
\pard\pardeftab720
{\field{\*\fldinst{HYPERLINK "http://illinois-cs.github.io/index.html"}}{\fldrslt 
\fs26 \cf5 \cb4 \expnd0\expndtw0\kerning0
Overview}}
\fs26 \cf5 \expnd0\expndtw0\kerning0
\
\pard\pardeftab720
{\field{\*\fldinst{HYPERLINK "http://illinois-cs.github.io/mps.html"}}{\fldrslt \cf5 \cb4 \expnd0\expndtw0\kerning0
MPs}}\
\pard\pardeftab720
{\field{\*\fldinst{HYPERLINK "http://illinois-cs.github.io/labs.html"}}{\fldrslt \cf5 \cb4 \expnd0\expndtw0\kerning0
Lab Sections}}\
\pard\pardeftab720
{\field{\*\fldinst{HYPERLINK "http://illinois-cs.github.io/help.html"}}{\fldrslt \cf5 \cb4 \expnd0\expndtw0\kerning0
Getting Help}}\
\pard\pardeftab720
{\field{\*\fldinst{HYPERLINK "http://illinois-cs.github.io/schedule.html"}}{\fldrslt \cf5 \cb4 \expnd0\expndtw0\kerning0
Schedule}}\
\pard\pardeftab720
{\field{\*\fldinst{HYPERLINK "http://illinois-cs.github.io/staff.html"}}{\fldrslt \cf5 \cb4 \expnd0\expndtw0\kerning0
Meet the Crew!}}\
\pard\pardeftab720

\fs28 \cf6 \expnd0\expndtw0\kerning0
Your content goes here\
\pard\pardeftab720

\fs112 \cf6 \expnd0\expndtw0\kerning0
Password Cracker\
\pard\pardeftab720

\fs28 \cf6 \expnd0\expndtw0\kerning0
\
\pard\pardeftab720

\b \cf6 \expnd0\expndtw0\kerning0
Due Date(s):
\b0 \expnd0\expndtw0\kerning0
 \
Part 1 due 3/14 11:59pm \
\pard\tx220\tx720\pardeftab720\li720\fi-720
\ls1\ilvl0\cf6 \kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
(Update:) Part 2 due 
\b \expnd0\expndtw0\kerning0
Wed 3/30
\b0 \expnd0\expndtw0\kerning0
 11:59pm 
\fs26 \expnd0\expndtw0\kerning0
Contents\uc0\u8232 
\fs32 \cf7 \expnd0\expndtw0\kerning0
Introduction\uc0\u8232 crypt_r()\u8232 Why is there salt in my hash?\u8232 Problem Statement\u8232 Input\u8232 Version 1: Thread Pool\u8232 Version 2: Parallelize each task\u8232 Building and Running\u8232 Helpful Extras
\fs28 \cf6 \expnd0\expndtw0\kerning0
\
\pard\pardeftab720

\f1\fs48 \cf1 \cb8 \expnd0\expndtw0\kerning0
Introduction
\f0\fs32 \cf6 \cb1 \expnd0\expndtw0\kerning0
\
\pard\pardeftab720

\fs28 \cf6 \expnd0\expndtw0\kerning0
In this MP, you will be creating a program that can recover lost passwords. For security reasons, passwords are usually never stored in plain text. Instead, the hashed versions of passwords are stored. For an example of this, take a look at the 
\f2 \expnd0\expndtw0\kerning0
/etc/shadow
\f0 \expnd0\expndtw0\kerning0
 file on any modern linux machine.\
When a user tries to log in, the password they enter is hashed and compared with the stored hash. This way, there\'92s no need to store your actual password.\
Given the output of a good hash function, it is hard or impossible to reconstruct the input using the hashed value. However, if you are willing to burn some CPU time, it is possible to try every possible password (brute force attack) until you find one such that hashes to the target hash.\
\pard\pardeftab720

\f2\fs48 \cf1 \cb8 \expnd0\expndtw0\kerning0
crypt_r()\cb1 \
\pard\pardeftab720

\f0\fs28 \cf6 \expnd0\expndtw0\kerning0
We will be using 
\f2 \expnd0\expndtw0\kerning0
crypt_r()
\f0 \expnd0\expndtw0\kerning0
 (a reentrant/thread safe version) of the 
\f2 \expnd0\expndtw0\kerning0
crypt()
\f0 \expnd0\expndtw0\kerning0
 function, as our hashing function. 
\f2 \expnd0\expndtw0\kerning0
crypt_r()
\f0 \expnd0\expndtw0\kerning0
 takes three arguments: the string to hash, a salt string, a 
\f2 \expnd0\expndtw0\kerning0
struct crypt_data
\f0 \expnd0\expndtw0\kerning0
. Make sure to set the 
\f2 \expnd0\expndtw0\kerning0
initialized
\f0 \expnd0\expndtw0\kerning0
 member of your 
\f2 \expnd0\expndtw0\kerning0
struct crypt_data
\f0 \expnd0\expndtw0\kerning0
 before using it for the first time. For example:\
\pard\pardeftab720

\f2\fs32 \cf9 \cb10 \expnd0\expndtw0\kerning0
struct\cf1 \expnd0\expndtw0\kerning0
 \cf11 \expnd0\expndtw0\kerning0
crypt_data\cf1 \expnd0\expndtw0\kerning0
 \cf11 \expnd0\expndtw0\kerning0
cdata;\cf1 \expnd0\expndtw0\kerning0
\
\cf11 \expnd0\expndtw0\kerning0
cdata.initialized\cf1 \expnd0\expndtw0\kerning0
 \cf12 \expnd0\expndtw0\kerning0
=\cf1 \expnd0\expndtw0\kerning0
 \cf13 \expnd0\expndtw0\kerning0
0\cf11 \expnd0\expndtw0\kerning0
;\cf1 \expnd0\expndtw0\kerning0
\
\
\cf9 \expnd0\expndtw0\kerning0
const\cf1 \expnd0\expndtw0\kerning0
 \cf9 \expnd0\expndtw0\kerning0
char\cf1 \expnd0\expndtw0\kerning0
 \cf12 \expnd0\expndtw0\kerning0
*\cf11 \expnd0\expndtw0\kerning0
hashed\cf1 \expnd0\expndtw0\kerning0
 \cf12 \expnd0\expndtw0\kerning0
=\cf1 \expnd0\expndtw0\kerning0
 \cf11 \expnd0\expndtw0\kerning0
crypt_r(\cf14 \expnd0\expndtw0\kerning0
"example1"\cf11 \expnd0\expndtw0\kerning0
,\cf1 \expnd0\expndtw0\kerning0
 \cf14 \expnd0\expndtw0\kerning0
"xx"\cf11 \expnd0\expndtw0\kerning0
,\cf1 \expnd0\expndtw0\kerning0
 \cf12 \expnd0\expndtw0\kerning0
&\cf11 \expnd0\expndtw0\kerning0
cdata);\cf1 \expnd0\expndtw0\kerning0
\
\cf11 \expnd0\expndtw0\kerning0
printf(\cf14 \expnd0\expndtw0\kerning0
"hash of 'example1' = %s\cf13 \expnd0\expndtw0\kerning0
\\n\cf14 \expnd0\expndtw0\kerning0
"\cf11 \expnd0\expndtw0\kerning0
,\cf1 \expnd0\expndtw0\kerning0
 \cf11 \expnd0\expndtw0\kerning0
hashed);\cf1 \expnd0\expndtw0\kerning0
\
\
\cf11 \expnd0\expndtw0\kerning0
hashed\cf1 \expnd0\expndtw0\kerning0
 \cf12 \expnd0\expndtw0\kerning0
=\cf1 \expnd0\expndtw0\kerning0
 \cf11 \expnd0\expndtw0\kerning0
crypt_r(\cf14 \expnd0\expndtw0\kerning0
"example2"\cf11 \expnd0\expndtw0\kerning0
,\cf1 \expnd0\expndtw0\kerning0
 \cf14 \expnd0\expndtw0\kerning0
"xx"\cf11 \expnd0\expndtw0\kerning0
,\cf1 \expnd0\expndtw0\kerning0
 \cf12 \expnd0\expndtw0\kerning0
&\cf11 \expnd0\expndtw0\kerning0
cdata);\cf1 \expnd0\expndtw0\kerning0
\
\cf11 \expnd0\expndtw0\kerning0
printf(\cf14 \expnd0\expndtw0\kerning0
"hash of 'example2' = %s\cf13 \expnd0\expndtw0\kerning0
\\n\cf14 \expnd0\expndtw0\kerning0
"\cf11 \expnd0\expndtw0\kerning0
,\cf1 \expnd0\expndtw0\kerning0
 \cf11 \expnd0\expndtw0\kerning0
hashed);\cf1 \expnd0\expndtw0\kerning0
\
\pard\pardeftab720

\f0\fs28 \cf6 \cb1 \expnd0\expndtw0\kerning0
This code outputs the following:\
\pard\pardeftab720

\f2\fs32 \cf11 \cb10 \expnd0\expndtw0\kerning0
hash\cf1 \expnd0\expndtw0\kerning0
 \cf11 \expnd0\expndtw0\kerning0
of\cf1 \expnd0\expndtw0\kerning0
 \cf15 \cb16 \expnd0\expndtw0\kerning0
'\cf11 \cb10 \expnd0\expndtw0\kerning0
example1\cf15 \cb16 \expnd0\expndtw0\kerning0
'\cf1 \cb10 \expnd0\expndtw0\kerning0
 \cf12 \expnd0\expndtw0\kerning0
=\cf1 \expnd0\expndtw0\kerning0
 \cf11 \expnd0\expndtw0\kerning0
xxPXiOTQGgNxc\cf1 \expnd0\expndtw0\kerning0
\
\cf11 \expnd0\expndtw0\kerning0
hash\cf1 \expnd0\expndtw0\kerning0
 \cf11 \expnd0\expndtw0\kerning0
of\cf1 \expnd0\expndtw0\kerning0
 \cf15 \cb16 \expnd0\expndtw0\kerning0
'\cf11 \cb10 \expnd0\expndtw0\kerning0
example2\cf15 \cb16 \expnd0\expndtw0\kerning0
'\cf1 \cb10 \expnd0\expndtw0\kerning0
 \cf12 \expnd0\expndtw0\kerning0
=\cf1 \expnd0\expndtw0\kerning0
 \cf11 \expnd0\expndtw0\kerning0
xx96r6\cf12 \expnd0\expndtw0\kerning0
/\cf11 \expnd0\expndtw0\kerning0
l1aOi.\cf1 \expnd0\expndtw0\kerning0
\
\pard\pardeftab720

\f0\fs28 \cf6 \cb1 \expnd0\expndtw0\kerning0
The 
\f2 \expnd0\expndtw0\kerning0
struct crypt_data
\f0 \expnd0\expndtw0\kerning0
 is necessary for 
\f2 \expnd0\expndtw0\kerning0
crypt_r()
\f0 \expnd0\expndtw0\kerning0
. This is because 
\f2 \expnd0\expndtw0\kerning0
crypt()
\f0 \expnd0\expndtw0\kerning0
 needs to store information between invocations, so calling 
\f2 \expnd0\expndtw0\kerning0
crypt()
\f0 \expnd0\expndtw0\kerning0
 on multiple threads will cause this information to be inaccurate. 
\f2 \expnd0\expndtw0\kerning0
crypt_r()
\f0 \expnd0\expndtw0\kerning0
 gets around this by storing information in a 
\f2 \expnd0\expndtw0\kerning0
struct crypt_data
\f0 \expnd0\expndtw0\kerning0
 instead. You should check the man page for 
\f2 \expnd0\expndtw0\kerning0
crypt_r,
\f0 \expnd0\expndtw0\kerning0
 do you need to free the string it returns?\
\pard\pardeftab720

\f1\fs48 \cf1 \cb8 \expnd0\expndtw0\kerning0
Why is there salt in my hash?
\f0\fs32 \cf6 \cb1 \expnd0\expndtw0\kerning0
\
\pard\pardeftab720

\fs28 \cf6 \expnd0\expndtw0\kerning0
The salt argument \'91flavors\'92 the string so that when you hash the same password twice, you\'92ll get a different result (if you use a different salt). For example, we can use part of a user\'92s username to salt their password before hashing. This way, two users with the same password will not have the same hash stored in the database.\
\pard\pardeftab720

\b \cf6 \expnd0\expndtw0\kerning0
For the sake of this assignment, always use 
\f3 \expnd0\expndtw0\kerning0
"xx"
\f0 \expnd0\expndtw0\kerning0
 for the salt argument.
\b0 \expnd0\expndtw0\kerning0
\
\pard\pardeftab720

\f1\fs48 \cf1 \cb8 \expnd0\expndtw0\kerning0
Problem Statement
\f0\fs32 \cf6 \cb1 \expnd0\expndtw0\kerning0
\
\pard\pardeftab720

\fs28 \cf6 \expnd0\expndtw0\kerning0
You will be given a list of password hashes which you must recover. Each password is a password partial, meaning that we have these two pieces of information:\
\pard\tx220\tx720\pardeftab720\li720\fi-720
\ls2\ilvl0\cf6 \kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
The first few letters in their password\
\ls2\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
The total length of the password\
\pard\pardeftab720

\b \cf6 \expnd0\expndtw0\kerning0
All the passwords only contain lowercase letters!
\b0 \expnd0\expndtw0\kerning0
\
For example, we may say that a password begins with 
\f2 \expnd0\expndtw0\kerning0
"hello"
\f0 \expnd0\expndtw0\kerning0
 and has a total of 8 letters. We know the hashed value associated with this password is 
\f2 \expnd0\expndtw0\kerning0
"xxsczBXm6z4zA"
\f0 \expnd0\expndtw0\kerning0
, so we simply have to try hashing each possible password (staring with the prefix provided) until we find one that hashes to the desired value.\
\pard\pardeftab720

\f1\fs48 \cf1 \cb8 \expnd0\expndtw0\kerning0
Input
\f0\fs32 \cf6 \cb1 \expnd0\expndtw0\kerning0
\
\pard\pardeftab720

\fs28 \cf6 \expnd0\expndtw0\kerning0
Your input will be a file with one line for each password to recover. Each line will contain:\
\pard\tx220\tx720\pardeftab720\li720\fi-720
\ls3\ilvl0\cf6 \kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
Username (1-8 characters)\
\ls3\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
Password (13 characters)\
\ls3\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
Known part of password (plus periods representing unknown characters) (1-8 characters, contains 0-8 lowercase letters followed by 0-8 periods)\
\pard\pardeftab720
\cf6 \expnd0\expndtw0\kerning0
These three fields are separated by a single space. Don\'92t worry about duplicate usernames, duplicate password hashes, or duplicate prefixes. Each line is an independent task.\
We will not provide input not in this format.\
Example input:\
\pard\pardeftab720

\f2\fs32 \cf1 \cb10 \expnd0\expndtw0\kerning0
donna xxC4UjY9eNri6 hello...\
eric xxqJ7cKzV3v4E zip.....\
francie xxGGPN89YLcGY cham....\
george xxq5aBqiB66j2 xz....\
helen xxhx0AsVpMTMU sysx....\
inigo xxHUf9zUctXNA miss....\
\pard\pardeftab720

\f1\fs48 \cf1 \cb8 \expnd0\expndtw0\kerning0
Version 1: Thread Pool
\f0\fs32 \cf6 \cb1 \expnd0\expndtw0\kerning0
\
\pard\pardeftab720

\b\fs28 \cf6 \expnd0\expndtw0\kerning0
We will not grade any output which is not the result of a call to a function in 
\f3 \expnd0\expndtw0\kerning0
format.h
\f0\b0 \expnd0\expndtw0\kerning0
\
You will not be graded on a single threaded implementation, but it is 
\b \expnd0\expndtw0\kerning0
always
\b0 \expnd0\expndtw0\kerning0
 a good idea to write a single threaded version of your code before trying to parallelize!\
Use multiple threads to speed up the password processing. The main thread will start up a pool of worker threads, then read lines of input from standard input. Each line will be converted to a task which is added to a task queue. The task queue is provided in 
\f2 \expnd0\expndtw0\kerning0
libprovided.a
\f0 \expnd0\expndtw0\kerning0
 and 
\f2 \expnd0\expndtw0\kerning0
queue.h.
\f0 \expnd0\expndtw0\kerning0
 It is very similar to the synchronized queue you\'92ve implemented in lab. The worker threads will pull one task from the task queue, then process the task. When a worker thread starts processing a task, it will print the username of the task (use 
\f2 \expnd0\expndtw0\kerning0
format.h
\f0 \expnd0\expndtw0\kerning0
).\
When a worker thread finishes a task, use 
\f2 \expnd0\expndtw0\kerning0
format.h
\f0 \expnd0\expndtw0\kerning0
 to print the cracked password, along with the index of the thread (starting with index 1), and the amount of CPU time spent working on the password (use 
\f2 \expnd0\expndtw0\kerning0
getThreadCPUTime()
\f0 \expnd0\expndtw0\kerning0
).\
When your main thread finishes reading in lines from the input, we can\'92t shut down immediately. The worker threads may still cracking some passwords. You need to decide how to cleanly shut all the threads down when there are no more passwords to crack. Every thread must join with the main thread!\
After all the worker threads have exited, the main thread will print (this is provided):\
\pard\tx220\tx720\pardeftab720\li720\fi-720
\ls4\ilvl0\cf6 \kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
Number of successful and unsuccessful password cracks\
\ls4\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
Wall clock time since the program was started (via 
\f2 \expnd0\expndtw0\kerning0
getTime()
\f0 \expnd0\expndtw0\kerning0
 in 
\f2 \expnd0\expndtw0\kerning0
utils.h
\f0 \expnd0\expndtw0\kerning0
)\
\ls4\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
CPU time used (a sum of the CPU time used in all threads).\
\ls4\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
Proportion of CPU time to wall clock time.\
\pard\pardeftab720
\cf6 \expnd0\expndtw0\kerning0
By default, the provided code creates 4 worker threads. If a command line argument is supplied to the program, it will use that as the number of worker threads rather than the default.\
Example:\
\pard\pardeftab720

\f2\fs32 \cf1 \cb10 \expnd0\expndtw0\kerning0
$ cat password_file.txt\
donna xxC4UjY9eNri6 hello...\
eric xxqJ7cKzV3v4E zip.....\
francie xxGGPN89YLcGY cham....\
george xxq5aBqiB66j2 xz....\
helen xxhx0AsVpMTMU sysx....\
inigo xxHUf9zUctXNA miss....\
$ ./cracker1 \cf12 \expnd0\expndtw0\kerning0
[\cf1 \expnd0\expndtw0\kerning0
thread_pool_size] <  password_file.txt\
\pard\pardeftab720

\f0\fs28 \cf6 \cb1 \expnd0\expndtw0\kerning0
Example output:\
\pard\pardeftab720

\f2\fs32 \cf1 \cb10 \expnd0\expndtw0\kerning0
Thread 1: Start donna\
Thread 4: Start francie\
Thread 3: Start george\
Thread 1: Password for donna is helloaac (3 hashes in 0.00 seconds)\
Thread 1: Start helen\
Thread 2: Start eric\
Thread 2: Password for eric is zipaaazz (676 hashes in 0.00 seconds)\
Thread 2: Start inigo\
Thread 1: Password for helen is sysxpert (266806 hashes in 1.05 seconds)\
Thread 2: Password for inigo is missudad (353552 hashes in 1.32 seconds)\
Thread 4: Password for francie not found (456976 hashes in 1.65 seconds)\
Thread 3: Password for george is xzzzzy (456975 hashes in 1.75 seconds)\
5 passwords recovered, 1 failed.\
Total time: 1.74 seconds.\
Total CPU time: 5.77 seconds.\
CPU usage: 3.31x\
\pard\pardeftab720

\f0\fs28 \cf6 \cb1 \expnd0\expndtw0\kerning0
The times and order may vary slightly.\
\pard\pardeftab720

\b \cf6 \expnd0\expndtw0\kerning0
Remember to use appropriate synchronization, and make sure to use 
\f3 \expnd0\expndtw0\kerning0
crypt_r
\f0 \expnd0\expndtw0\kerning0
.
\b0 \expnd0\expndtw0\kerning0
 If you create a new thread for each task (instead of keeping the threads in the thread pool running), you will loose points! (and your implementation will be very slow)\
\pard\pardeftab720

\f1\fs48 \cf1 \cb8 \expnd0\expndtw0\kerning0
Version 2: Parallelize each task
\f0\fs32 \cf6 \cb1 \expnd0\expndtw0\kerning0
\
\pard\pardeftab720

\b\fs28 \cf6 \expnd0\expndtw0\kerning0
We will not grade any output which is not the result of a call to a function in 
\f3 \expnd0\expndtw0\kerning0
format.h
\f0\b0 \expnd0\expndtw0\kerning0
\
Version 1 works great when there is a long list of passwords that need cracking in parallel, but it\'92s no faster than a single threaded version when there\'92s one really hard password that needs cracking. For version 2, you\'92ll still have a pool of threads, but rather than assigning one thread to each password task, all the threads will work in parallel on each password task.\
Example input:\
\pard\pardeftab720

\f2\fs32 \cf1 \cb10 \expnd0\expndtw0\kerning0
maude xxEe0WApyDMcg a......\
jesse xxsJNywggi0lA za......\
francie xxGGPN89YLcGY cham....\
\pard\pardeftab720

\f0\fs28 \cf6 \cb1 \expnd0\expndtw0\kerning0
Example output:\
\pard\pardeftab720

\f2\fs32 \cf1 \cb10 \expnd0\expndtw0\kerning0
Start maude\
Thread 2: Start maude at 77228944 (agnaaaa)\
Thread 4: Start maude at 231686832 (atnaaaa)\
Thread 1: Start maude at 0 (aaaaaaa)\
Thread 3: Start maude at 154457888 (anaaaaa)\
Thread 1: Stop after 308332 iterations (found)\
Thread 3: Stop after 327747 iterations (cancelled)\
Thread 4: Stop after 337977 iterations (cancelled)\
Thread 2: Stop after 318970 iterations (cancelled)\
Password for maude is aaarocx (1293026 hashes in 1.72 seconds)\
Total CPU time: 6.41 seconds.\
CPU usage: 3.72x\
Start jesse\
Thread 3: Start jesse at 154457888 (zanaaaaa)\
Thread 4: Start jesse at 231686832 (zatnaaaa)\
Thread 1: Start jesse at 0 (zaaaaaaa)\
Thread 2: Start jesse at 77228944 (zagnaaaa)\
Thread 2: Stop after 945682 iterations (found)\
Thread 4: Stop after 968171 iterations (cancelled)\
Thread 3: Stop after 966968 iterations (cancelled)\
Thread 1: Stop after 911765 iterations (cancelled)\
Password for jesse is zagpbuyj (3792586 hashes in 3.24 seconds)\
Total CPU time: 12.77 seconds.\
CPU usage: 3.94x\
Start francie\
Thread 4: Start francie at 342732 (chamtnaa)\
Thread 3: Start francie at 228488 (chamnaaa)\
Thread 1: Start francie at 0 (chamaaaa)\
Thread 2: Start francie at 114244 (chamgnaa)\
Thread 4: Stop after 114244 iterations (end)\
Thread 3: Stop after 114244 iterations (end)\
Thread 2: Stop after 114244 iterations (end)\
Thread 1: Stop after 114244 iterations (end)\
Password for francie not found (456976 hashes in 0.40 seconds)\
Total CPU time: 1.53 seconds.\
CPU usage: 3.81x\
\pard\pardeftab720

\f0\fs28 \cf6 \cb1 \expnd0\expndtw0\kerning0
Distribute the work by splitting the search space into equal-sized chunks, one for each worker thread. For example, if there are 3 unknown characters, then there are 26^3 = 17576 possible passwords that need to be tested. With 4 worker threads, you would split the work up like this:\
\pard\tx220\tx720\pardeftab720\li720\fi-720
\ls5\ilvl0\cf6 \kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
Thread 1: 0..4393 (aaa..gmz)\
\ls5\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
Thread 2: 4394..8787 (gna..mzz)\
\ls5\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
Thread 3: 8788..13181 (naa..tmz)\
\ls5\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
Thread 4: 13182..17575 (tna..zzz)\
\pard\pardeftab720
\cf6 \expnd0\expndtw0\kerning0
When the number of threads doesn\'92t divide the search space evenly, it\'92s easy to get off-by-one errors due to integer rounding. We\'92ve provided functions 
\f2 \expnd0\expndtw0\kerning0
getSubrange()
\f0 \expnd0\expndtw0\kerning0
 and 
\f2 \expnd0\expndtw0\kerning0
setStringPosition()
\f0 \expnd0\expndtw0\kerning0
 to help you with this.\
With all the threads working on the same task, you may want to restructure your thread synchronization a little. Rather than a queue, you may wish to use a barrier.\
\pard\pardeftab720

\f2\fs16 \cf1 \cb10 \expnd0\expndtw0\kerning0
                Startup     Task 0..............................   Task 1..............................\
\
main thread:    read task | idle      | print results, read next | idle      | print results, read next\
worker threads: idle      | computing | idle                     | computing | idle\
                          
\f4 \uc0\u8593 
\f2 \
                       barrier\
\pard\pardeftab720

\f0\fs28 \cf6 \cb1 \expnd0\expndtw0\kerning0
Like with version 1, you may not create new threads for each task. The threads you create at the beginning of the program must be the same threads that compute the last task.\
When the main thread reads a task, it should print 
\f2 \expnd0\expndtw0\kerning0
"Start <username>"
\f0 \expnd0\expndtw0\kerning0
. When a thread starts processing a task, it should print its index and starting position. As usual, make sure to use 
\f2 \expnd0\expndtw0\kerning0
format.h
\f0 \expnd0\expndtw0\kerning0
. For example:\
\pard\pardeftab720

\f2\fs32 \cf1 \cb10 \expnd0\expndtw0\kerning0
% echo eric xxqJ7cKzV3v4E zip..... | ./cracker2\
Start eric\
Thread 1: Start eric at 0 (zipaaaaa)\
Thread 2: Start eric at 2970344 (zipgnaaa)\
Thread 4: Start eric at 8911032 (ziptnaaa)\
Thread 3: Start eric at 5940688 (zipnaaaa)\
\pard\pardeftab720

\f0\fs28 \cf6 \cb1 \expnd0\expndtw0\kerning0
When a worker thread finds the correct password, it should tell all the other threads to stop working on the task. You can implement this with a simple flag variable that each thread checks on each iteration. Since all the threads are reading this variable and any thread may write to it, you\'92ll need to properly synchronize access to it.\
When the worker threads finish a task, each thread will print the number of passwords it tried and a word describing how its run finished:\
\pard\tx220\tx720\pardeftab720\li720\fi-720
\ls6\ilvl0\cf6 \kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
(found) - this thread found the password\
\ls6\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
(cancelled) - stopped early because another thread found the password\
\ls6\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
(end) - finished with no password found. Note: this can happen if the password was found, but this thread finished its chunk before another thread found the password.\
\pard\pardeftab720
\cf6 \expnd0\expndtw0\kerning0
After all worker threads finish each task, the main thread will print the password (if found), the total number of hashes, the wall clock and CPU time spent on that task, and the ratio of CPU time to wall clock time. Note that we have not provided any of the timing print statements in 
\f2 \expnd0\expndtw0\kerning0
cracker2
\f0 \expnd0\expndtw0\kerning0
.\
\pard\pardeftab720

\f1\fs48 \cf1 \cb8 \expnd0\expndtw0\kerning0
Building and Running
\f0\fs32 \cf6 \cb1 \expnd0\expndtw0\kerning0
\
\pard\pardeftab720

\fs28 \cf6 \expnd0\expndtw0\kerning0
As usual, we have provided a Makefile which can build a 
\f2 \expnd0\expndtw0\kerning0
release
\f0 \expnd0\expndtw0\kerning0
 and a 
\f2 \expnd0\expndtw0\kerning0
debug
\f0 \expnd0\expndtw0\kerning0
 version of your code. Running 
\f2 \expnd0\expndtw0\kerning0
make
\f0 \expnd0\expndtw0\kerning0
 will compile 
\f2 \expnd0\expndtw0\kerning0
cracker1
\f0 \expnd0\expndtw0\kerning0
 and 
\f2 \expnd0\expndtw0\kerning0
cracker2
\f0 \expnd0\expndtw0\kerning0
 in release mode, as well as a tool called 
\f2 \expnd0\expndtw0\kerning0
create_examples
\f0 \expnd0\expndtw0\kerning0
 (more on this in the next section). Running 
\f2 \expnd0\expndtw0\kerning0
make debug
\f0 \expnd0\expndtw0\kerning0
 will compile 
\f2 \expnd0\expndtw0\kerning0
cracker1
\f0 \expnd0\expndtw0\kerning0
 and 
\f2 \expnd0\expndtw0\kerning0
cracker2
\f0 \expnd0\expndtw0\kerning0
 in debug mode, and will also compile 
\f2 \expnd0\expndtw0\kerning0
create_examples.
\f0 \expnd0\expndtw0\kerning0
\
\pard\pardeftab720

\f1\fs48 \cf6 \expnd0\expndtw0\kerning0
ThreadSanitizer
\f0\fs28 \expnd0\expndtw0\kerning0
\
We have also included the target 
\f2 \expnd0\expndtw0\kerning0
make tsan
\f0 \expnd0\expndtw0\kerning0
, which compiles your code with Thread Sanitizer (run 
\f2 \expnd0\expndtw0\kerning0
cracker1-tsan
\f0 \expnd0\expndtw0\kerning0
 and 
\f2 \expnd0\expndtw0\kerning0
cracker2-tsan
\f0 \expnd0\expndtw0\kerning0
)\
ThreadSantizer is a race condition detection tool. See {\field{\*\fldinst{HYPERLINK "http://illinois-cs.github.io/tsan"}}{\fldrslt \cf17 \expnd0\expndtw0\kerning0
this page}} for more information.\
\pard\pardeftab720

\b \cf6 \expnd0\expndtw0\kerning0
We will be using ThreadSanitizer to grade your code! If the autograder detects a data race, you won\'92t automatically get 0 points, but a few points will be deducted.
\b0 \expnd0\expndtw0\kerning0
\
\pard\pardeftab720

\f1\fs48 \cf1 \cb8 \expnd0\expndtw0\kerning0
Helpful Extras
\f0\fs32 \cf6 \cb1 \expnd0\expndtw0\kerning0
\
\pard\pardeftab720

\f1\fs48 \cf6 \expnd0\expndtw0\kerning0
Thread status hook
\f0\fs28 \expnd0\expndtw0\kerning0
\
We\'92ve provided a simple tool to help you when debugging your program. See 
\f2 \expnd0\expndtw0\kerning0
thread_status.h
\f0 \expnd0\expndtw0\kerning0
 and 
\f2 \expnd0\expndtw0\kerning0
thread_status.c
\f0 \expnd0\expndtw0\kerning0
. We\'92ve install 
\f2 \expnd0\expndtw0\kerning0
threadStatusPrint()
\f0 \expnd0\expndtw0\kerning0
 as a handler for 
\f2 \expnd0\expndtw0\kerning0
SIGINT
\f0 \expnd0\expndtw0\kerning0
. It will print a brief summary of what each thread is currently doing any time you hit ctrl-c. For example:\
\pard\pardeftab720

\f2\fs32 \cf1 \cb10 \expnd0\expndtw0\kerning0
% ./cracker2 cracker2.in 2 100000 2\
Start u0000000\
Start u0000001\
^C\
** Thread 0: semaphore wait at cracker2.c:219\
** Thread 1: processing at cracker2.c:269\
** Thread 2: processing at cracker2.c:269\
\pard\pardeftab720

\f0\fs28 \cf6 \cb1 \expnd0\expndtw0\kerning0
To use it:\
\pard\tx220\tx720\pardeftab720\li720\fi-720
\ls7\ilvl0
\f2 \cf6 \kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
#include "thread_status.h"
\f0 \expnd0\expndtw0\kerning0
\
\pard\tx220\tx720\pardeftab720\li720\fi-720
\ls7\ilvl0\cf6 \kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
Call threadStatusSet() to describe what the thread is currently doing. The argument to 
\f2 \expnd0\expndtw0\kerning0
threadStatusSet()
\f0 \expnd0\expndtw0\kerning0
 should be a string constant. For example:\
\pard\pardeftab720

\f2\fs32 \cf11 \cb10 \expnd0\expndtw0\kerning0
threadStatusSet(\cf14 \expnd0\expndtw0\kerning0
"initializing"\cf11 \expnd0\expndtw0\kerning0
);\cf1 \expnd0\expndtw0\kerning0
\
\cf11 \expnd0\expndtw0\kerning0
...\cf1 \expnd0\expndtw0\kerning0
\
\cf9 \expnd0\expndtw0\kerning0
while\cf1 \expnd0\expndtw0\kerning0
 \cf11 \expnd0\expndtw0\kerning0
(\cf12 \expnd0\expndtw0\kerning0
!\cf11 \expnd0\expndtw0\kerning0
done)\cf1 \expnd0\expndtw0\kerning0
 \cf11 \expnd0\expndtw0\kerning0
\{\cf1 \expnd0\expndtw0\kerning0
\
  \cf11 \expnd0\expndtw0\kerning0
threadStatusSet(\cf14 \expnd0\expndtw0\kerning0
"waiting for task"\cf11 \expnd0\expndtw0\kerning0
);\cf1 \expnd0\expndtw0\kerning0
\
  \cf11 \expnd0\expndtw0\kerning0
task\cf1 \expnd0\expndtw0\kerning0
 \cf12 \expnd0\expndtw0\kerning0
=\cf1 \expnd0\expndtw0\kerning0
 \cf11 \expnd0\expndtw0\kerning0
queue_pull(task_queue);\cf1 \expnd0\expndtw0\kerning0
\
  \cf11 \expnd0\expndtw0\kerning0
threadStatusSet(\cf14 \expnd0\expndtw0\kerning0
"processing"\cf11 \expnd0\expndtw0\kerning0
);\cf1 \expnd0\expndtw0\kerning0
\
  \cf11 \expnd0\expndtw0\kerning0
...\cf1 \expnd0\expndtw0\kerning0
\
\cf11 \expnd0\expndtw0\kerning0
\}\cf1 \expnd0\expndtw0\kerning0
\
\pard\pardeftab720

\f0\fs28 \cf6 \cb1 \expnd0\expndtw0\kerning0
When 
\f2 \expnd0\expndtw0\kerning0
threadStatusPrint()
\f0 \expnd0\expndtw0\kerning0
 is called, it doesn\'92t print the exact line number that each thread is at. It just prints the line number of the most recent call to 
\f2 \expnd0\expndtw0\kerning0
threadStatusSet()
\f0 \expnd0\expndtw0\kerning0
. So, for more precise reporting, add more calls to 
\f2 \expnd0\expndtw0\kerning0
threadStatusSet()
\f0 \expnd0\expndtw0\kerning0
 to your code.\
\pard\pardeftab720

\f2 \cf6 \expnd0\expndtw0\kerning0
thread_status.h
\f0 \expnd0\expndtw0\kerning0
 contains macros that will redefine calls to common thread synchronization functions so that when a thread is blocking on one of them, its status will represent that (like the \'93semaphore wait\'94 on line 219 in the example above).\
\pard\pardeftab720

\b \cf6 \expnd0\expndtw0\kerning0
Note: Since Thread Status is hooked to Ctrl-C, you might need to use Ctrl-D (EOF) or Ctrl-\\ (SIGQUIT) to shutdown a running password cracker
\b0 \expnd0\expndtw0\kerning0
\
You\'92re not required to use the thread status tool as part of the assignment, we just thought it might make your debugging easier.\
\pard\pardeftab720

\f1\fs48 \cf6 \expnd0\expndtw0\kerning0
create_examples
\f0\fs28 \expnd0\expndtw0\kerning0
\
We\'92ve also provided a small program to create example input files, to help you with your testing. To build the 
\f2 \expnd0\expndtw0\kerning0
create_examples
\f0 \expnd0\expndtw0\kerning0
 program, run 
\f2 \expnd0\expndtw0\kerning0
make create_examples
\f0 \expnd0\expndtw0\kerning0
. To use the program, write it\'92s output to a file, then use the file as input to a cracker program. For example:\
\pard\pardeftab720

\f2\fs32 \cf1 \cb10 \expnd0\expndtw0\kerning0
./create_examples 10 100 150 > my_examples.in \cf18 \expnd0\expndtw0\kerning0
# write the output to a file\cf1 \expnd0\expndtw0\kerning0
\
./cracker1 < my_examples.in\
\pard\pardeftab720

\f0\fs28 \cf6 \cb1 \expnd0\expndtw0\kerning0
To see what the cracked passwords should be, use the 
\f2 \expnd0\expndtw0\kerning0
-soln
\f0 \expnd0\expndtw0\kerning0
 flag when running 
\f2 \expnd0\expndtw0\kerning0
create_examples
\f0 \expnd0\expndtw0\kerning0
 (see the usage documentation given when running the program with no arguments).\
\pard\pardeftab720

\f1\fs48 \cf6 \expnd0\expndtw0\kerning0
timing example
\f0\fs28 \expnd0\expndtw0\kerning0
\
CPU time and so called \'93wall clock\'94 time are not always the same thing. CPU time is defined as \'93the amount of time your program spends running on a CPU,\'94 and wall clock time is quite literally, the amount of time that would pass on a wall clock (the kind of clock on a wall) between the time a program starts and a program finishes running. These numbers are often not the same!\
If your program makes a large number of blocking system calls, it may take 10 seconds to run, but only actually consume 5 seconds of CPU time. In this case, the kernel spent time reading from a file, or writing packets to the network, while your program sat idle.\
CPU time can also be much larger than wall clock time. If a program runs in multiple threads, it may use 40 seconds of CPU time, but only take 10 seconds of wall clock time (4 threads, each ran for 10 seconds).\
To demonstrate these differences, we\'92ve provided a program in 
\f2 \expnd0\expndtw0\kerning0
tools/timing.c
\f0 \expnd0\expndtw0\kerning0
 which shows an example of both kinds cases.\
To compile this program, run 
\f2 \expnd0\expndtw0\kerning0
make timing
\f0 \expnd0\expndtw0\kerning0
, then run 
\f2 \expnd0\expndtw0\kerning0
./timing.
\f0 \expnd0\expndtw0\kerning0
 You should see output like this:\
\pard\pardeftab720

\f2\fs32 \cf1 \cb10 \expnd0\expndtw0\kerning0
sleep\cf12 \expnd0\expndtw0\kerning0
(\cf1 \expnd0\expndtw0\kerning0
1\cf12 \expnd0\expndtw0\kerning0
)\cf1 \expnd0\expndtw0\kerning0
: 1.00 seconds wall \cf11 \expnd0\expndtw0\kerning0
time\cf1 \expnd0\expndtw0\kerning0
, 0.00 seconds CPU \cf11 \expnd0\expndtw0\kerning0
time\
\cf1 \expnd0\expndtw0\kerning0
single threaded cpu work: 0.14 seconds wall \cf11 \expnd0\expndtw0\kerning0
time\cf1 \expnd0\expndtw0\kerning0
, 0.14 seconds CPU \cf11 \expnd0\expndtw0\kerning0
time\
\cf1 \expnd0\expndtw0\kerning0
multi threaded cpu work: 0.14 seconds wall \cf11 \expnd0\expndtw0\kerning0
time\cf1 \expnd0\expndtw0\kerning0
, 0.28 seconds CPU \cf11 \expnd0\expndtw0\kerning0
time}