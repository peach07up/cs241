{\rtf1\ansi\ansicpg936\cocoartf1348\cocoasubrtf170
{\fonttbl\f0\fswiss\fcharset0 Helvetica;\f1\fswiss\fcharset0 Helvetica-Light;\f2\fmodern\fcharset0 Courier;
\f3\fmodern\fcharset0 Courier-Bold;}
{\colortbl;\red255\green255\blue255;\red48\green58\blue166;\red51\green51\blue51;\red249\green249\blue249;
\red98\green98\blue98;\red26\green26\blue26;\red66\green199\blue218;\red19\green151\blue241;\red252\green34\blue110;
\red29\green30\blue26;}
{\*\listtable{\list\listtemplateid1\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid1\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid1}
{\list\listtemplateid2\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid101\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid2}
{\list\listtemplateid3\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid201\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid3}
{\list\listtemplateid4\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}}{\leveltext\leveltemplateid301\'01\'00;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listname ;}\listid4}
{\list\listtemplateid5\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid401\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}}{\leveltext\leveltemplateid402\'01\'01;}{\levelnumbers\'01;}\fi-360\li1440\lin1440 }{\listname ;}\listid5}}
{\*\listoverridetable{\listoverride\listid1\listoverridecount0\ls1}{\listoverride\listid2\listoverridecount0\ls2}{\listoverride\listid3\listoverridecount0\ls3}{\listoverride\listid4\listoverridecount0\ls4}{\listoverride\listid5\listoverridecount0\ls5}}
\paperw11900\paperh16840\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\deftab720
\pard\pardeftab720\qc

\f0\fs48 \cf1 \cb2 \expnd0\expndtw0\kerning0
menu
\fs52 \expnd0\expndtw0\kerning0
\
\pard\pardeftab720

\fs28 \cf1 \expnd0\expndtw0\kerning0
Title
\fs40 \cb1 \expnd0\expndtw0\kerning0
\
\pard\pardeftab720
\cf1 \cb2 CS 241 : System Programming\cb1 \
\pard\pardeftab720

\fs28 \cf1 \cb2 \expnd0\expndtw0\kerning0
Add spacer, to align navigation to the right\cb1 \expnd0\expndtw0\kerning0
\
\
\cb2 \expnd0\expndtw0\kerning0
Navigation. We hide it in small screens.
\fs26 \cb1 \expnd0\expndtw0\kerning0
\
\pard\pardeftab720
{\field{\*\fldinst{HYPERLINK "http://illinois-cs.github.io/index.html"}}{\fldrslt \cf1 \cb2 Overview}}\
\pard\pardeftab720
{\field{\*\fldinst{HYPERLINK "http://illinois-cs.github.io/mps.html"}}{\fldrslt \cf1 \cb2 \expnd0\expndtw0\kerning0
MPs}}\
\pard\pardeftab720
{\field{\*\fldinst{HYPERLINK "http://illinois-cs.github.io/labs.html"}}{\fldrslt \cf1 \cb2 \expnd0\expndtw0\kerning0
Lab Sections}}\
\pard\pardeftab720
{\field{\*\fldinst{HYPERLINK "http://illinois-cs.github.io/help.html"}}{\fldrslt \cf1 \cb2 \expnd0\expndtw0\kerning0
Getting Help}}\
\pard\pardeftab720
{\field{\*\fldinst{HYPERLINK "http://illinois-cs.github.io/schedule.html"}}{\fldrslt \cf1 \cb2 \expnd0\expndtw0\kerning0
Schedule}}\
\pard\pardeftab720
{\field{\*\fldinst{HYPERLINK "http://illinois-cs.github.io/staff.html"}}{\fldrslt \cf1 \cb2 \expnd0\expndtw0\kerning0
Meet the Crew!}}\
\pard\pardeftab720

\fs40 \cf3 \cb4 \expnd0\expndtw0\kerning0
CS 241\cb1 \
\pard\pardeftab720
{\field{\*\fldinst{HYPERLINK "http://illinois-cs.github.io/index.html"}}{\fldrslt 
\fs26 \cf5 \cb4 \expnd0\expndtw0\kerning0
Overview}}
\fs26 \cf5 \expnd0\expndtw0\kerning0
\
\pard\pardeftab720
{\field{\*\fldinst{HYPERLINK "http://illinois-cs.github.io/mps.html"}}{\fldrslt \cf5 \cb4 \expnd0\expndtw0\kerning0
MPs}}\
\pard\pardeftab720
{\field{\*\fldinst{HYPERLINK "http://illinois-cs.github.io/labs.html"}}{\fldrslt \cf5 \cb4 \expnd0\expndtw0\kerning0
Lab Sections}}\
\pard\pardeftab720
{\field{\*\fldinst{HYPERLINK "http://illinois-cs.github.io/help.html"}}{\fldrslt \cf5 \cb4 \expnd0\expndtw0\kerning0
Getting Help}}\
\pard\pardeftab720
{\field{\*\fldinst{HYPERLINK "http://illinois-cs.github.io/schedule.html"}}{\fldrslt \cf5 \cb4 \expnd0\expndtw0\kerning0
Schedule}}\
\pard\pardeftab720
{\field{\*\fldinst{HYPERLINK "http://illinois-cs.github.io/staff.html"}}{\fldrslt \cf5 \cb4 \expnd0\expndtw0\kerning0
Meet the Crew!}}\
\pard\pardeftab720

\fs28 \cf6 \expnd0\expndtw0\kerning0
Your content goes here\
\pard\pardeftab720

\fs112 \cf6 \expnd0\expndtw0\kerning0
Et Tu Brute\
\pard\pardeftab720

\fs28 \cf6 \expnd0\expndtw0\kerning0
\
\pard\tx220\tx720\pardeftab720\li720\fi-720
\ls1\ilvl0
\b \cf6 \kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
Due Date(s):
\b0 \expnd0\expndtw0\kerning0
 04/13 11:59pm 
\fs26 \expnd0\expndtw0\kerning0
Contents\uc0\u8232 
\fs32 \cf7 \expnd0\expndtw0\kerning0
Learning Objectives\uc0\u8232 Backstory\u8232 Files\u8232 Usage\u8232 Reference: Single Process Version\u8232 Mission: Can we do it in time?\u8232 Hints\u8232 Error Cases
\fs28 \cf6 \expnd0\expndtw0\kerning0
\
\pard\pardeftab720

\f1\fs48 \cf1 \cb8 \expnd0\expndtw0\kerning0
Learning Objectives
\f0\fs32 \cf6 \cb1 \expnd0\expndtw0\kerning0
\
\pard\tx220\tx720\pardeftab720\li720\fi-720
\ls2\ilvl0
\fs28 \cf6 \kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
File Descriptors\
\ls2\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
Pipes\
\ls2\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
Forking with Pipes (IPC)\
\ls2\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
Reading and Writing from Pipes\
\ls2\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
Process-level parallelism\
\pard\pardeftab720

\f1\fs48 \cf1 \cb8 \expnd0\expndtw0\kerning0
Backstory
\f0\fs32 \cf6 \cb1 \expnd0\expndtw0\kerning0
\
\pard\pardeftab720

\fs28 \cf6 \expnd0\expndtw0\kerning0
You are an intern for Marcus Junius Brutus.\
Brutus is planning the assassination of Julius Caesar, dictator of the Roman Senate. In order to do so he must know the exact whereabouts of Caesar and when he will be most vulnerable.\
A visitor who claims to be from the future gives you a \expnd0\expndtw0\kerning0
\strike \strikec6 file\expnd0\expndtw0\kerning0
\strike0\striked0  journal that has all of this information. The visitor has encrypted the journal to avoid the information from falling into the wrong hands. He warns Brutus to read it with discretion. The journal is encrypted with a {\field{\*\fldinst{HYPERLINK "https://en.wikipedia.org/wiki/Caesar_cipher"}}{\fldrslt \cf9 \expnd0\expndtw0\kerning0
caesar cipher}}, which has a well known solution for {\field{\*\fldinst{HYPERLINK "https://en.wikipedia.org/wiki/Caesar_cipher#Breaking_the_cipher"}}{\fldrslt \cf9 \expnd0\expndtw0\kerning0
breaking}} it and decrypting the cipher.\
Your fellow interns are already aware of the techniques for breaking the encryption, so you do not need to worry about it. There is a catch. Caesar is well aware of these decryption techniques as well, so he encrypts every line of the journal with an arbitrary shift amount. To make matters worse, your fellow \expnd0\expndtw0\kerning0
\strike \strikec6 slaves\expnd0\expndtw0\kerning0
\strike0\striked0  interns who are brute forcing all the possible ciphers take long naps and the journal only documents Caesar\'92s whereabouts for the next couple of days. This means time is of the essence. So in order to decrypt the journal in time, Brutus has asked you to assign each line of the journal to an intern to decrypt. At the end you will stitch all their work together and write it to a new journal for Brutus to read.\
Simple right? Except that some lines are longer than others, you need to wait for all the interns to finish, and you need to write it all back in order for it to make sense to Brutus.\
\pard\pardeftab720

\f1\fs48 \cf1 \cb8 \expnd0\expndtw0\kerning0
Files
\f0\fs32 \cf6 \cb1 \expnd0\expndtw0\kerning0
\
\pard\tx220\tx720\pardeftab720\li720\fi-720
\ls3\ilvl0
\fs28 \cf6 \kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
cipher.h - header file for the decryption library.\
\ls3\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
Makefile - the makefile you should use to build.\
\ls3\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
journal.txt - a newline separated journal that you must decrypt.\
\ls3\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
brutus.c - main file which will contain your implementation for brute forcing caesar ciphers.\
\pard\pardeftab720

\f1\fs48 \cf1 \cb8 \expnd0\expndtw0\kerning0
Usage
\f0\fs32 \cf6 \cb1 \expnd0\expndtw0\kerning0
\
\pard\pardeftab720

\f2 \cf1 \cb10 \expnd0\expndtw0\kerning0
./brutus <input_file_path> <output_file_path>\
\pard\pardeftab720

\f0\fs28 \cf6 \cb1 \expnd0\expndtw0\kerning0
For example\
\pard\pardeftab720

\f2\fs32 \cf1 \cb10 \expnd0\expndtw0\kerning0
./brutus input.txt output.txt\
\pard\pardeftab720

\f1\fs48 \cf1 \cb8 \expnd0\expndtw0\kerning0
Reference: Single Process Version
\f0\fs32 \cf6 \cb1 \expnd0\expndtw0\kerning0
\
\pard\pardeftab720

\fs28 \cf6 \expnd0\expndtw0\kerning0
It is quite simple to do the decryption in single process version. First we read from file. For each line we read, we call 
\f3\b \expnd0\expndtw0\kerning0
get_most_likely_printout()
\f0\b0 \expnd0\expndtw0\kerning0
 and get decrypted line.\
\pard\pardeftab720
\cf6 \expnd0\expndtw0\kerning0
{{\NeXTGraphic et_tu_brute.001.png \width20480 \height15360 \noorient
}¬}\pard\pardeftab720
\cf6 \expnd0\expndtw0\kerning0
\
\pard\pardeftab720

\f1\fs48 \cf1 \cb8 \expnd0\expndtw0\kerning0
Mission: Can we do it in time?
\f0\fs32 \cf6 \cb1 \expnd0\expndtw0\kerning0
\
\pard\pardeftab720

\fs28 \cf6 \expnd0\expndtw0\kerning0
Decryption in real life is usually slow and therefore single process version cannot complete the job in time. We can use process-level parallelism to solve this problem. We can assign each line to one child process and ask them to finish their job. In order to gather decryptions from children, we need a way to do IPC(Inter Process Communication). We can use pipes to achieve this. Following are instructions to help you complete the mission.\
\pard\pardeftab720

\f1\fs48 \cf6 \expnd0\expndtw0\kerning0
Parse the arguments
\f0\fs28 \expnd0\expndtw0\kerning0
\
This should be done by calling the 
\f2 \expnd0\expndtw0\kerning0
arg_parse()
\f0 \expnd0\expndtw0\kerning0
 function. Note that the input file will always be newline separated.\

\f1\fs48 \expnd0\expndtw0\kerning0
Make 1 pipe (read and write end) and store 1 pid for each child
\f0\fs28 \expnd0\expndtw0\kerning0
\
You will need to do this in order to have Interprocess communication (IPC)\

\f1\fs48 \expnd0\expndtw0\kerning0
Notice that you should create EXACTLY ONE CHILD for EACH LINE
\f0\fs28 \expnd0\expndtw0\kerning0
\
You need one pipe per child, since you need a read end for the parent and a write end for the child.\

\f1\fs48 \expnd0\expndtw0\kerning0
Assign 1 line to each child process to decrypt
\f0\fs28 \expnd0\expndtw0\kerning0
\
This is where the magic happens. Remember that when forking with pipes, it is common practice to close the unnecessary (unused) end of each pipe in the child and parent process. This is to avoid the awkward scenario where a process is listening to itself. You need to find some way for the parent process to give the line to decrypt to its child. One somewhat hacky solution is to have the parent read the line from the file then fork. The child now has its own copy of the line. Once the child has the line to decrypt, you should have it call on the 
\f2 \expnd0\expndtw0\kerning0
get_most_likely_printout()
\f0 \expnd0\expndtw0\kerning0
 function from cipher.o. Once your child is done decrypting a line, it should write into the write end of its pipe so that the parent can later read from it. If a child has no more work then it should close all remaining ends to its pipe and exit.\
The following is the workflow for the first-half of the program. \expnd0\expndtw0\kerning0
{{\NeXTGraphic et_tu_brute.002.png \width20480 \height15360 \noorient
}¬}\expnd0\expndtw0\kerning0
\

\f1\fs48 \expnd0\expndtw0\kerning0
Collect the decryptionsYou must wait for you children in this step
\f0\fs28 \expnd0\expndtw0\kerning0
\
Like any responsible parent your parent process should wait on its children. This is where having remembered your children\'92s\'92 pids come in handy. Once you are done waiting for all your children to finish you can start reading from your pipes sequentially. ### Write all the decryptions to a file Now that you have all your children\'92s print outs you can write them to the output file in the same order as the lines in the original file. You should write exactly what you read from your children and not a single byte more.\
The following is the workflow for the second-half of the program \expnd0\expndtw0\kerning0
{{\NeXTGraphic et_tu_brute.003.png \width20480 \height15360 \noorient
}¬}\expnd0\expndtw0\kerning0
\
\pard\pardeftab720

\f1\fs48 \cf1 \cb8 \expnd0\expndtw0\kerning0
Hints
\f0\fs32 \cf6 \cb1 \expnd0\expndtw0\kerning0
\
\pard\pardeftab720

\f1\fs48 \cf6 \expnd0\expndtw0\kerning0
What can I do with fcntl?
\f0\fs32 \expnd0\expndtw0\kerning0
\
\pard\pardeftab720

\f2 \cf1 \cb10 \expnd0\expndtw0\kerning0
int fcntl(int fd, int cmd, ... /* arg */ );\
\pard\pardeftab720

\f0\fs28 \cf6 \cb1 \expnd0\expndtw0\kerning0
We can do a lot of things on a file 
\b \expnd0\expndtw0\kerning0
fd
\b0 \expnd0\expndtw0\kerning0
 by using the function fcntl. The operations includes duplicating file descriptor, retrieving file status, and many operations. If you are interested you can find reference {\field{\*\fldinst{HYPERLINK "http://goo.gl/ntLfPD"}}{\fldrslt \cf9 \expnd0\expndtw0\kerning0
here}}.\
\pard\pardeftab720

\f1\fs48 \cf6 \expnd0\expndtw0\kerning0
How can I use it?
\f0\fs28 \expnd0\expndtw0\kerning0
\
In this lab, we want you to learn how to change the capacity of a pipe. A pipe has limited capacity and writing to a full pipe 
\b \expnd0\expndtw0\kerning0
might be blocked
\b0 \expnd0\expndtw0\kerning0
 or 
\b \expnd0\expndtw0\kerning0
failed
\b0 \expnd0\expndtw0\kerning0
.\
Then how can this be useful? Remember in this lab, you need to:\
\pard\tx220\tx720\pardeftab720\li720\fi-720
\ls4\ilvl0\cf6 \kerning1\expnd0\expndtw0 {\listtext	1	}\expnd0\expndtw0\kerning0
Let each child process decrypts a line and write to a pipe.\
\ls4\ilvl0\kerning1\expnd0\expndtw0 {\listtext	2	}\expnd0\expndtw0\kerning0
Let parent process 
\b \expnd0\expndtw0\kerning0
wait for all
\b0 \expnd0\expndtw0\kerning0
 child processes to finish their job and 
\b \expnd0\expndtw0\kerning0
then
\b0 \expnd0\expndtw0\kerning0
 collect the decryptions.\
\pard\pardeftab720
\cf6 \expnd0\expndtw0\kerning0
Now, if some lines are too long, processes decrypting the lines cannot return from their write operation and have to wait for the parent process to read something out from their pipes. However, the parent process will be waiting for all its children until they finish their job. What concurrent programming situation did we hit here? ;-)\
The following is a picture to help you understand this problem. Notice that pipe 2 and some other pipes are full (marked as red). Therefore, process 
\i \expnd0\expndtw0\kerning0
pid2
\i0 \expnd0\expndtw0\kerning0
 is blocked on write and waits for the parent process to read some bytes from its pipe 
\i \expnd0\expndtw0\kerning0
pipe2
\i0 \expnd0\expndtw0\kerning0
. However, the parent process is waiting for all its children and won\'92t move on to next step (read from pipe).\
\pard\pardeftab720
\cf6 \expnd0\expndtw0\kerning0
{{\NeXTGraphic et_tu_brute.004.png \width20480 \height15360 \noorient
}¬}\pard\pardeftab720
\cf6 \expnd0\expndtw0\kerning0
\
\pard\pardeftab720

\f1\fs48 \cf6 \expnd0\expndtw0\kerning0
Solution
\f0\fs28 \expnd0\expndtw0\kerning0
\
We can set the size of the pipe according to the length of the longest line in the file. Then there will be no blocking issue.\

\f1\fs48 \expnd0\expndtw0\kerning0
What can I do with arg_parse
\f0\fs28 \expnd0\expndtw0\kerning0
\
Note that the command line input provided to your program is just the input file to decrypt and output file to write decrypted content to. Before you spawn off child processes to decrypt individual lines, there are several intermediate steps you need to worry about for correctness: * Get the number of lines in the input file * Number of bytes in the longest line of the input file * FILE pointer to the input file * FILE pointer to the output file\
If you are not sure why you need the above information, make sure you think about it and convince yourself about their use before moving forward. The arg_parse function implements the required operations to obtain all of the above-mentioned data. It returns void pointer to a pointer with the above data in order that you can read from. You would need to keep the following points in mind about how arg_parse works: * It will prompt the user if they don\'92t have the right arguments. * It will prompt the user if the input file is not readable. * It will prompt the user if the output file is not writable. * Will rewind() the input file pointer so it can be used to read file content. * It is the callers responsibility to free up any memory and file resources that the caller obtains from calling arg_parse function\
\pard\pardeftab720

\f1\fs48 \cf1 \cb8 \expnd0\expndtw0\kerning0
Error Cases
\f0\fs32 \cf6 \cb1 \expnd0\expndtw0\kerning0
\
\pard\pardeftab720

\fs28 \cf6 \expnd0\expndtw0\kerning0
As always, you are expected to write test cases to ensure your implementation satisfies all the requirements in specification provided. For this purpose, come up with test cases without looking at your implementation and focusing on points described in specification. Some example cases to think about could include:\
\pard\tx220\tx720\pardeftab720\li720\fi-720
\ls5\ilvl0\cf6 \kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
Input to the function: Make sure you have test cases for any problems with input arguments provided to the function. E.g. correct number of arguments were not provided, the input file is empty or not readable, etc.\
\ls5\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
Main functionality: Make sure you have basic test cases to make sure your implementation is correctly decrypting the input file content. The actual output file can be compared to an expected output file for example\
\ls5\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
Corner cases: There could be several corner cases you could possibly test for. Example corner scenarios to think about could include (please see NOTE below):\
\pard\tx940\tx1440\pardeftab720\li1440\fi-1440
\ls5\ilvl1\cf6 \kerning1\expnd0\expndtw0 {\listtext	1	}\expnd0\expndtw0\kerning0
What if duplicate lines are read and you may end up with a mismatch in expected and actual size of output file?\
\ls5\ilvl1\kerning1\expnd0\expndtw0 {\listtext	2	}\expnd0\expndtw0\kerning0
What if the pipe gets destroyed while it is being used by the parent/child processes.\
\ls5\ilvl1\kerning1\expnd0\expndtw0 {\listtext	3	}\expnd0\expndtw0\kerning0
What if the one or more of child processes get killed during the process of decryption?\
\ls5\ilvl1\kerning1\expnd0\expndtw0 {\listtext	4	}\expnd0\expndtw0\kerning0
Can the output file incorrectly be written by multiple processes and result in it\'92s content being non-deterministic?\
\ls5\ilvl1\kerning1\expnd0\expndtw0 {\listtext	5	}\expnd0\expndtw0\kerning0
Have you correctly set the pipe size to ensure no deadlock occurs in your implementation?\
\pard\tx220\tx720\pardeftab720\li720\fi-720
\ls5\ilvl0\cf6 \kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
NOTE: We do not expect you to test for all these corner cases for this lab as implementing them can be quite challenging. However we are listing them out as food for thought. We want you to stretch your minds when thinking about your code quality and be aware of all the possible ways in which your code can be broken. That is the only way to ensure your code is robust, no shortcuts there :) So even though these tests are not required, we would still encourage you to pick one or two that you think are important and implement them.}